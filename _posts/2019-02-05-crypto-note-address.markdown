---
layout: post
title:  "Bitcoin: The Address"
date:   2019-01-20 20:00:00 +0100
author: Anders Konring
toc: true
categories: cryptonote monero bitcoin cryptography
tags: [research, blockchain, monero]
---

The other day a friend asked me why Monero addresses are longer than Bitcoin addresses.
That question sent me down a rabbit hole comparing the internals of Bitcoin and Crypto Note (Monero).

The coming posts are dedicated to defining the key differences between Bitcoin and Monero on a crypto and protocol level.

## Bitcoin Address Format

Let's take a look the most widely used address format in Bitcoin:  
Pay-To-Public-Key-Hash (P2PKH).
An address of this type looks like this:  
```
A: 1Je3RohZT6mH1AofjcjMJXgbVgKrJNVohD
```
Behind the address `A` there is a public key. The entity who owns the corresponding private key can spend the coins on the address.

There are multiple steps involved in the process of generating a bitcoin address.

### ECDSA

Bitcoin uses an algorithm called Elliptic Curve Digital Signature Algorithm ([ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)) with an underlying elliptic curve named after its parameters: [Secp256k1](http://www.secg.org/sec2-v2.pdf).
The curve has a so-called base point $$G$$ which is a generator of the corresponding group.  
A key-pair is generated by choosing $$r\in (1\dots n-1)$$ where $$n$$ is the order of the generator $$G$$.  
Surprisingly, the number of points on an elliptic curve can be computed using [Schoof's algorithm](https://en.wikipedia.org/wiki/Schoof's_algorithm).
In the case of [Secp256k1](http://www.secg.org/sec2-v2.pdf) the number of decimal digits in the order, $$n$$, is:
```
>>> n = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"
>>> len(str(int(n, 16)))
78
```
Which indicates a number which is close to the [estimated number of atoms in the universe](https://en.wikipedia.org/wiki/Observable_universe#Matter_content_%E2%80%93_number_of_atoms).
The resulting level of security is approximately $$2^{128}$$ bits[^2].

The following scalar multiplication[^1] is done to derive the public key from the private key, $$r$$:

$$
P=r\times G=(x,y)
$$

In [Secp256k1](http://www.secg.org/sec2-v2.pdf) the maximum value of $$r$$ is $$n-1$$ which is almost $$2^{256}$$ and the public key is a coordinate $$(x, y)$$ where both $$x$$ and $$y$$ can also be represented by a 256 bits.

By using the fact that $$E$$ is symmetric about the x-axis the coordinate can be represented with only the $$x$$-coordinate and an initial byte to define whether $$y$$ is positive or negative.
In total the compressed representation of the public key is 33 bytes.
![Elliptic Curve](/assets/elliptic.png)

### From Public Key to Address

In order to go from the compressed public key described above to the Base58 characters of `A` we need to do some work.

#### Hashing

Regardless of the coordinate type the public key is hashed using [SHA256](https://en.wikipedia.org/wiki/SHA-2) and [RIPEMD160](https://en.wikipedia.org/wiki/RIPEMD), respectively.
The resulting string $$R$$ is 21 bytes with an initial byte added to identify the network (see drawing).

![Hashing](/assets/hash.png)

#### Checksum
The final steps in the processing consist of computing a checksum and encode the bytes using [base58](https://en.wikipedia.org/wiki/Base58).
The checksum is computed by applying the hash function (SHA256) twice to $$R$$ and select the first 4 bytes of the resulting string.

These 4 bytes are concatenated with $$R$$ and comprise the address of 25 bytes.
The 25 bytes are encoded using base58 and the resulting string is 26-34 characters depending on the number of leading zero bytes.

![Hashing](/assets/base58.png)

[^1]: Elliptic curve point multiplication can be visualized in the plane [example](https://infosecwriters.com/text_resources/pdf/Elliptic_Curve_AnnopMS.pdf).
[^2]: Excellent post about the security level of Secp256k1: [John D. Cook - blog](https://www.johndcook.com/blog/2018/08/14/bitcoin-elliptic-curves/)
